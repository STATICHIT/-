#include<stdio.h>
int a[1000000+10],b[1000000+10];//先开几个比要求范围大一点的数组
int main()
{
    int n,k,i,num;
    while(~scanf("%d%d",&n,&k))
    {
        for(i = 0; i < n; i++)
        {
            scanf("%d",&a[i]);
            if(i == 0)
                {b[i] = a[i];}//因为差分数组是：b[i]=a[i]-a[i-1]，而当其为第一项时差分数组数值应为原数组第一项本身
            else
                {b[i] = a[i] - a[i - 1];}//差分数组基本格式：邻项之差!!!
        }

        for(i = 0; i < n; i++)
        {
            b[i + 1] += a[i];/*一般情况要使原数组的部分区间【x，y】中的数值改变，则应对区间两端点所求的差分数值进行修改。
		                        例如 要使a【10】数组（下标从0到9）的区间【1，3】中的元素数值加‘1’，则应使b[1]+=1(b[1]=a[1]-a[0])、
                                b[3+1]-=1。但在这里由于有多个区间同时变化且区间范围均是基于a【i】数组（空调房间的编号）来判断，
		                        唯一可以确定的就是当前所选的a[i](当前选定的空调房）（的序号）左右第一个房间必受影响（a[i-1]与a[i+1]的数值
		                        一定会因a[i]改变），所以对当前所选的a[i](当前选定的空调房）（的序号）左右房间所求的差分数值分开当作两个区间
		                        进行考虑，修改。 所以先左右第一个房间所求的差分数值进行修改，为了方便，先对右边第一个房间所求差分数值修改*/
            if(i + k + 1 >= n)
                {b[n - 1] = b[n - 1];}/*如果当前所选的a[i](当前选定的空调房）的影响范围已超过已有的房间数，则最后的房间保持原数值
                                        即可*/
            else
                {b[i + k + 1] = b[i + k + 1] - a[i];}/*如果当前所选的a[i](当前选定的空调房）的影响范围未超过已有的房间数，
                                                       则处于区间末端点的房间减去数值a[i]，以保证后续房间数值不受a[i]影响*/
            if(i-k > 0)//上面已经对a[i]右侧房间考虑完毕，下面对a[i]左侧房间进行考虑。考虑方法同上
            {
                b[i - k] = b[i - k] + a[i];//这里对差分数组区间第一项进行修改，赋值
                b[i] = b[i] - a[i];//a[i]房的温度（数值）不会改变本身房间的温度（数值）
            }
            if(i-k <= 0)
            {
                b[0] = b[0] + a[i];//这里对差分数组第一项进行修改，赋值
                b[i] = b[i] - a[i];
            }
        }

        for(i = 0; i < n; i++)
        {
            if(i == 0)
                {a[i] = b[i];}//因为差分数组从第2项（a[1])开始作用(b[i]=a[i]-a[i-1]),所以第一项就是差分数组b【1】本身
            else
                {a[i] = b[i] + a[i-1];}///后面就是差分的逆操作：b[i]=a[i]-a[i-1]  ===>>  a[i]=b[i]+a[i-1]
        }

        int max = a[0];
        for(i = 0; i < n; i++)//这样子操作遇i后面的项但是和当前max相等时的项就不会进入循环，从而达到最热空调有多台时输出序号最小的那台
        {
            if(max < a[i])
            {
                max = a[i];//a[i]项温度最高
                num = i;
            }
        }
        printf("%d\n",num+1);//a[i]项是第i+1个数据即代表第i+1台空调
    }
    return 0;
}
